ПРОЦЕССЫ В LINUX

Процессы - исполняемая в текущий момент программа, общее определение механизма, позволяющего управлять памятью, временем работы и прерываниями процессора, ресурсами ввода вывода. При запуске программы командой активации создается соответствующий процесс. Пока программа не запущена - это файл, после запуска - процесс. 

Программу можно запустить как по названию или полностью прописав путь к исполняемому файлу. По названию программа будет запущена если она есть в папках, перечисленных в переменной окружения PATH, в которой живет список папок где операционная система ищет исполняемые файлы. 

# echo $PATH - посмотреть что в ней живет

Если в этих каталогах проги нет, нужно прописать полный путь к исполняемому файлу, или перейти в папку с этим файлом и использовать ./my_program 

Все процессы состоят из компонентов. К ним относится адресное пространство и набор структур данных ядра. 

Адресное пространство - набор блоков памяти выделенных ядром процессу.

Структура данных - хранит информацию о процессе: текущее состояние, песурсы, владелец, приоритеты, & etc.

Идентификаторы процесса

PID (Process ID) - уникальный идентификатор.

PPID (Parent Process ID) - Linux для выполнения программ не создает новый процесс, а какой то из существующих клонирует себя, а потом заменяет текущую выполняемую программу на новую. Исходный процесс - родительский, клон - дочерний. Дочернему присваивается собственный PID, но помимо этого он имеет атрибут PPID, совпадающий с PID родительского процесса. Может случится, что родительский процесс будет завершен раньше дочернего. в этом случае демон systemd (init или другой в зависимости от дистрибутива) подставит себя на место родителя. systemd всегда имеет идентификатор '1'.

UID (User ID) - идентификатор пользователя, создавшего процесс.

GID (Group ID) - идентификатор группы создателя процесса.

Контроль и мониторинг

Утилита ps. Утилита клёвая, но капитально замороченная. Недостаток - делает снимок системы в момент запроса. Соответственно во время изучения вывода данные в нем перестают быть актуальными. 

# ps 'опция'  -- базовый вид

# ps 'опция' | grep 'параметр' -- чего нить грепнуть когда точно знаешь чего хочешь))) 

-A, -e -- выбрать все процессы;
-a -- выбрать все процессы кроме фоновых;
-d -- выбрать все процессы, включая фоновые, кроме процессов сессий;
N -- выбрать все процессы кроме указанных;
-C -- выбор процессы по имени команд;
-G -- выбор по ID группы;
-p -- выбор по PID;
--ppid -- выбор по PID родительского процесса;
-s -- выбор по ID сессии;
-t -- выбор по tty;
-u -- выбор по юзеру.
Опции форматирования:

-c -- отображать информацию планировщика;
-f -- вывести все доступные данные;
-F -- выводит откуда то еще больше данных чем -f)))));
-l -- длинный формат;
-j -- вывести процессы в стиле jobs;
-M Z -- добавить инфу о безопасности;
-o, o, --format <format> -- позволяет определить свой формат вывода;
--sort -- сортировка по указанной колонке;
-L -- отображать потоки процессов в колонках LWP и NLWP;
-m -- вывести потоки после процесса;
-V -- инфа о версии;
-H - отображать древо
-X - register format
& etc. Короче, --help (там правда есть нюансы запроса инфы))) ) ну и флаг в руки, да ветер в спину))))

# ps - только собственные процессы

# ps -aux # -a -- увидеть все процессы, -u -- дополнительная фильтрация по пользовательским параметрам, -x -- показать все процессы, в том числе не относящиеся к управляющему терминалу. 

USER -- владелец процесса

PID -- идентификатор процесса

%CPU -- доля времени в процентах выделенная процессу

%MEM -- часть опреативной памяти в процентах используемая процессом 

VSZ -- виртуальный размер процесса

RSS -- количество блоков памяти

PSR -- ядро процессора на котором выполняется процесс

TTY -- идентификатор управляющего терминала

'R' -- процесс выполняется в данный момент

'S' --  процесс ожидает

'I' -- процесс ожидает (т.е. спит менее 20 секунд)

'Z' -- zombie - завершившийся процесс, код возврата которого не считан родителем, пока или вобще

STAT -- 

'T' -- процесс остановлен

'D' -- ожидает записи на диск

'<' -- процесс в приоритетном режиме

'N' -- процесс в режиме низкого приоритета

'L' -- real-time процесс, имеются страницы, заблокированные в памяти

's' -- лидер сессии

START -- время запуска процесса

TIME -- время затраченное на выполнение процесса

COMMAND -- команда которой процесс был запущен. Если команда в квадратных скобках - это поток ядра, запланированный в качестве процесса.

# ps -l -- добавит такое:

'F' -- флаги ассоциированные с процессом

'S' -- состояние процесса

'PRI' -- приоритет процесса

'NI' -- рекомендованный приоритет процесса (можно менять)

'ADDR' -- адрес процесса в памяти

'WCHAN' -- название функции ядра из-за которой процесс сидит в режиме ожидания.

Так же там несчитано разновсяких вариантов вывода, вплоть до своих собственных предпочтений. Опять же man или --help - и совершенству нет предела. (чет я утомился от этого ps сегодня))) ). 

Однако, зачастую, целесообразней использовать эту команду с выводом на pgrep:
# ps axww | grep cron
# ps axjf # Все процессы в виде дерева (Linux)
# ps aux | grep 'ss[h]' # Найти все PID процесса ssh, исключая PID процесса grep

# pgrep -l sshd -- Найти PID процесса по имени(или по его части)
# echo $$ -- PID процесса текушей оболочки
# pmap PID -- Карта памяти процессов, выявление утечек
памяти
# strace df -- Отслеживать(Trace) системные вызовы и сигналы. strace -отдельная установка утилиты.

Программа top

Показывает рабочие данные по запущенным процессам. Для получения справки по ключам, во время работы top,
нажать h.

Некоторые ключи:
• u [имя пользователя] — Посмотреть процессы принадлежащие конкретному
пользователю. ''empty' для возврата в режим полного просмотра.
• k [PID] — Убить (завершить) процесс с PID.
• 1 — Показать статистику по процессору 
• R — Переключить сортировку

htop - красивый цветастый и более наглядный top c расширенным функционалом. Там все более гуишно, есть функциональные клавиши, хелп и все такое. Не могу вспомнить чтоб я его устанавливал отдельно))) потому мне кажется, что в последних сборках Debian он идет по дефолту как и top/

Команда kill
Остановка процессов или отправка сигнала с помощью команд kill или killall.

# ping -i 60 cb.vu > ping.log &
[1] 4712
# kill -s TERM 4712 # то-же что и kill -15 4712
# killall -1 httpd # отправить сигнал HUP процессу с точным именем
# pkill -9 http # отправить сигнал TERM процессу с именем или
его частью
# pkill -TERM -u www # отправить сигнал TERM процессу выполняющемусяот имени конкретного пользователя
Наиболее важные сигналы:
• 1 HUP — Часто используется для перечитывания конфигурационных файлов
• 2 INT — Прервать(interrupt)
• 3 QUIT — Выйти
• 9 KILL — Безусловно прибить процесс
• 15 TERM — Мягкое прерывание

 

Приоритет процесса


Изменить приоритет процесса можно командой renice. Отрицательное значение, означает
более высокий приоритет.
# renice -5 586 # Повысить приоритет процесса с PID 586
586: old priority 0, new priority -5
C помощью nice можно запускать процессы с определенным приоритетом. Что-бы узнать,
используете вы, /usr/bin/nice или nice встроенный в шелл, используйте which nice).
# nice -n -5 top # Повысить приоритет процесса(/usr/bin/nice)
# nice -n 5 top # Понизить приоритет процесса(/usr/bin/nice)
# nice +5 top # nice Встроенный в шелл, понизить приоритет
процесса
В то время как nice отвечает за распределение процессорного времени, другая полезная
команда ionice, распределяет дисковый IO. Она весьма полезна в случае приложений, активно
использующих дисковый IO (например компилирование). Вы можете установить для
приложения соответствующий класс (idle — best effort — real time), загляните в man, там все
довольно доступно рассказано

# ionice c3 -p123 # Установить класс idle для pid 123 (только
Linux)
# ionice -c2 -n0 firefox # Запустить Фаерфокс с высоким приоритетом и
классом best effort
# ionice -c3 -p$$ # Установить для текущей оболочки класс idla
Последняя команда очень полезна при компилировании или отладке больших проектов. Любая
команда, запущенная из текущей оболочки будет иметь пониженный приоритет. Переменная $
$, содержит PID текушей оболочки (попробуйте echo $$)
FreeBSD использует idprio/rtprio (0 = максимальный приоритет, 31 = наиболее свободный(most
idle)):
# idprio 31 make # Компилировать с низким приоритетом
# idprio 31 -1234 # Установить низкий приоритет для PID 1234
# idprio -t -1234 # -t удаляет real time/idle приоритеты
background/foreground
Процессы запущенные в шелле, можно переключать в фоновый режим (background),
приостанавливать, нажав [Ctrl]-[Z], и выводить обратно в foreground, так-же можно использовать
команды bg and fg. Команда jobs, выведет списох запущенных в фоновом режиме процессов

# ping cb.vu > ping.log
^Z # Команда ping приостановлена [Ctrl]-[Z]
# bg # Отправить в фон и продолжать выполнение
# jobs -l # Список фоновых процессов
[1] - 36232 Running ping cb.vu > ping.log
[2] + 36233 Suspended (tty output) top
# fg %2 # Вернуть процесс 2 в обычный режим
Что-бы процесс продолжал свое выполнение после закрытия оболочки, можно воспользоваться
командой nohup.
# nohup ping -i 60 > ping.log &

Демон cron
